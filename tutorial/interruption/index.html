<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Interruption - IOFiber</title>
  <meta property="og:title" content="Interruption" />
  <meta name="twitter:title" content="Interruption" />
  <meta name="description" content="If a fiber is stalled waiting for some IO request that might never complete you still can use the interruption API to stop the fiber. The fiber interruption API was inspired by the POSIX thread cancellation API (and Boost.Thread)[1].
 Interrupting a fiber If you want to interrupt a fiber, call fiber::interrupt(). An interruption request will be queued for near delivery to interrupt the fiber.
 The fiber will react to the interruption request when it next calls a function that is a suspension point (or if it is currently suspended whilst executing one).">
  <meta property="og:description" content="If a fiber is stalled waiting for some IO request that might never complete you still can use the interruption API to stop the fiber. The fiber interruption API was inspired by the POSIX thread cancellation API (and Boost.Thread)[1].
 Interrupting a fiber If you want to interrupt a fiber, call fiber::interrupt(). An interruption request will be queued for near delivery to interrupt the fiber.
 The fiber will react to the interruption request when it next calls a function that is a suspension point (or if it is currently suspended whilst executing one).">
  <meta name="twitter:description" content="If a fiber is stalled waiting for some IO request that might never complete you still can use the interruption API to stop the fiber. The fiber interruption API was inspired by the POSIX thread …"><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "IOFiber",
    
    "url": "https:\/\/vinipsmaker.github.io\/iofiber\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/vinipsmaker.github.io\/iofiber\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/vinipsmaker.github.io\/iofiber\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/vinipsmaker.github.io\/iofiber\/tutorial\/interruption\/",
          "name": "Interruption"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : ""
  },
  "headline": "Interruption",
  "description" : "If a fiber is stalled waiting for some IO request that might never complete you still can use the interruption API to stop the fiber. The fiber interruption API was inspired by the POSIX thread cancellation API (and Boost.Thread)[1].\n Interrupting a fiber If you want to interrupt a fiber, call fiber::interrupt(). An interruption request will be queued for near delivery to interrupt the fiber.\n The fiber will react to the interruption request when it next calls a function that is a suspension point (or if it is currently suspended whilst executing one).",
  "inLanguage" : "en",
  "wordCount":  1354 ,
  "datePublished" : "0001-01-01T00:00:00",
  "dateModified" : "0001-01-01T00:00:00",
  "image" : "https:\/\/vinipsmaker.github.io\/iofiber\/",
  "keywords" : [ "" ],
  "mainEntityOfPage" : "https:\/\/vinipsmaker.github.io\/iofiber\/tutorial\/interruption\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/vinipsmaker.github.io\/iofiber\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/vinipsmaker.github.io\/iofiber\/",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Interruption" />
<meta property="og:description" content="If a fiber is stalled waiting for some IO request that might never complete you still can use the interruption API to stop the fiber. The fiber interruption API was inspired by the POSIX thread cancellation API (and Boost.Thread)[1].
 Interrupting a fiber If you want to interrupt a fiber, call fiber::interrupt(). An interruption request will be queued for near delivery to interrupt the fiber.
 The fiber will react to the interruption request when it next calls a function that is a suspension point (or if it is currently suspended whilst executing one).">
<meta property="og:url" content="https://vinipsmaker.github.io/iofiber/tutorial/interruption/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="IOFiber" />
  <meta name="twitter:title" content="Interruption" />
  <meta name="twitter:description" content="If a fiber is stalled waiting for some IO request that might never complete you still can use the interruption API to stop the fiber. The fiber interruption API was inspired by the POSIX thread …">
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://vinipsmaker.github.io/iofiber/tutorial/interruption/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="IOFiber" />

  <meta name="generator" content="Hugo 0.73.0" />
  <link rel="alternate" href="https://vinipsmaker.github.io/iofiber/index.xml" type="application/rss+xml" title="IOFiber">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://vinipsmaker.github.io/iofiber/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://vinipsmaker.github.io/iofiber/css/highlight.min.css" /><link rel="stylesheet" href="https://vinipsmaker.github.io/iofiber/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://vinipsmaker.github.io/iofiber/">IOFiber</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Tutorials(7)" href="/iofiber/tutorial/">Tutorials(7)</a>
            </li>
          
        
          
            <li>
              <a title="Reference(3)" href="/iofiber/ref/">Reference(3)</a>
            </li>
          
        

        

        
      </ul>
    </div>

    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="tutorial-heading">
              
                <h1>Interruption</h1>
              
              
                <hr class="small">
              
              
              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <div class="paragraph">
<p>If a fiber is stalled waiting for some IO request that might never complete you
still can use the interruption API to stop the fiber. The fiber interruption API
was inspired by the POSIX thread cancellation API (and
Boost.Thread)<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
<div class="sect1">
<h2 id="_interrupting_a_fiber">Interrupting a fiber</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you want to interrupt a fiber, call <code>fiber::interrupt()</code>. An interruption
request will be queued for near delivery to interrupt the fiber.</p>
</div>
<div class="paragraph">
<p>The fiber will react to the interruption request when it next calls a function
that is a suspension point (or if it is currently <em>suspended</em> whilst executing
one). If the target fiber has disabled interruption, then the interruption
request remains queued until the fiber enables interruption <em>and</em> reaches a new
suspension point.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The semantics are the same of a POSIX&#8217;s <code>PTHREAD_CANCEL_DEFERRED</code> thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the interruption request is delivered by throwing a
<code>fiber_interrupted</code> exception originating at the suspension point. Unless this
exception is caught inside the interrupted fiber&#8217;s start-function, the stack
unwinding process (as with any other exception) causes the destructors with
automatic storage duration to be executed. Unlike other exceptions, when
<code>fiber_interrupted</code> is propagated out of fiber&#8217;s start-function, this does not
cause the call to <code>std::terminate</code>; the effect is as though the fiber&#8217;s
start-function has returned normally.</p>
</div>
<div class="paragraph">
<p>To avoid accidental trap of the <code>fiber_interrupted</code> exception, this class
doesn&#8217;t inherit <code>std::exception</code>.</p>
</div>
<div class="paragraph">
<p>You can check whether the fiber finished by normal means or by letting the
<code>fiber_interrupted</code> exception escape its stack by using
<code>fiber::interruption_caught()</code> (after joining it). If the <code>fiber_interrupted</code>
exception escaped the stack, then <code>fiber::interruption_caught()</code> will return
<code>true</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>fiber::interruption_caught()</code> exposes the information that POSIX
otherwise offers through <code>PTHREAD_CANCELED</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reacting_to_interruption_requests">Reacting to interruption requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When a fiber is interrupted and reaches a suspension point, a
<code>fiber_interrupted</code> exception will be throw and you&#8217;ll be unable to perform any
operation that would otherwise suspend the fiber.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>It is safe to catch and swallow the <code>fiber_interrupted</code> exception using
try-catch blocks. If you do this, <code>interruption_caught()</code> will return
<code>false</code>.</p>
</div>
<div class="paragraph">
<p>However, catching the <code>fiber_interrupted</code> exception is not enough to disable
interruptions and perform operations abstracted with suspending functions. As
soon as you call the suspending function within the catch block, another
<code>fiber_interrupted</code> exception will be throw (operation will not even start for
what it is worth).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_disabling_interruptions">Disabling interruptions</h3>
<div class="paragraph">
<p>If you wish to temporarily disable interruptions and stay capable of using
suspending functions, just instantiate an object of the class
<code>fiber::this_fiber::disable_interruption</code>. Objects of this class disable
interruption for the fiber that created them on construction, and restore the
interruption state to whatever it was before on destruction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f(fiber::this_fiber this_fiber)
{
  // interruption enabled here
  {
    fiber::this_fiber::disable_interruption di{this_fiber};
    // interruption disabled
    {
      fiber::this_fiber::disable_interruption di2{this_fiber};
      // interruption still disabled
    } // di2 destroyed, interruption state restored
    // interruption still disabled
  } // di destroyed, interruption state restored
  // interruption now enabled
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effects of an instance of <code>fiber::this_fiber::disable_interruption</code> can be
temporarily reversed by constructing an instance of
<code>fiber::this_fiber::restore_interruption</code>, passing in the
<code>fiber::this_fiber::disable_interruption</code> object in question. This will restore
the interruption state to what it was when the
<code>fiber::this_fiber::disable_interruption</code> object was constructed, and then
disable interruption again when the <code>fiber::this_fiber::restore_interruption</code>
object is destroyed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void g(fiber::this_fiber this_fiber)
{
  // interruption enabled here
  {
    fiber::this_fiber::disable_interruption di{this_fiber};
    // interruption disabled
    {
      fiber::this_fiber::restore_interruption ri{di};
      // interruption now enabled
    } // ri destroyed, interruption disable again
  } // di destroyed, interruption state restored
  // interruption now enabled
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This provides the functionality that POSIX otherwise offers through
<code>pthread_setcancelstate()</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_async_functions"><code>async_*</code> functions</h3>
<div class="paragraph">
<p>When a fiber is interrupted at an <code>async_*</code> function, the underlying IO request
isn&#8217;t cancelled immediately. Usually, this is not a problem because in code
pieces like this (which should be most of the code out there)&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void start(fiber::this_fiber this_fiber)
{
  boost::asio::steady_timer timer{this_fiber.get_executor().context()};
  timer.expires_after(std::chrono::seconds(1));

  boost::system::error_code ec;
  timer.async_wait(this_fiber[ec]);
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;if the fiber is interrupted, stack unwinding will play on and destruct the
underlying IO objects causing the operations to be aborted.</p>
</div>
<div class="paragraph">
<p>However, this behaviour is less than ideal and for this reason you can customize
the interrupter by filling the <code>this_fiber.interrupter</code> variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void start(fiber::this_fiber this_fiber)
{
  boost::asio::steady_timer timer{this_fiber.get_executor().context()};
  timer.expires_after(std::chrono::seconds(1));

  this_fiber.interrupter = [&amp;timer]() { timer.cancel(); };

  boost::system::error_code ec;
  timer.async_wait(this_fiber[ec]);
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately you still have to translate the
<code>boost::asio::error::operation_aborted</code> error to a <code>fiber_interrupted</code> exception
in this example on the suspension-site if you want to
<code>fiber::interruption_caught()</code> to report exit reason correctly. To simplify
matters further, the following syntax sugar is provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;trial/iofiber/interrupter/asio/basic_waitable_timer.hpp&gt;

void start(fiber::this_fiber this_fiber)
{
  boost::asio::steady_timer timer{this_fiber.get_executor().context()};
  timer.expires_after(std::chrono::seconds(1));

  boost::system::error_code ec;
  timer.async_wait(this_fiber[ec].with_intr(timer));
  // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<h2 id="_example" class="discrete">Example</h2>
<div class="paragraph">
<p>When you do operations involving buffers, it&#8217;s a common requirement that you
keep the buffer accessible until the operation completes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void start(fiber::this_fiber this_fiber)
{
  // ...

  boost::system::error_code ec;
  BufferType buf;
  boost::asio::async_read(socket, buf, this_fiber[ec]);
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you rely on the default (no) interrupter (as in the example), then you have a
problem. <code>buf</code> might be destroyed due to stack unwinding on <code>fiber_interrupted</code>
while the <code>async_read()</code> operation is in progress.</p>
</div>
<div class="paragraph">
<p>The solution is easy. Teach IOFiber how to interrupt the operation so the fiber
wakeup (to throw <code>fiber_interrupted</code>) synchronizes with the cancellation of the
underlying operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void start(fiber::this_fiber this_fiber)
{
  // ...

  // Must handle `operation_aborted` explicitly later
  this_fiber.interrupter = [&amp;socket]() { socket.cancel(); };

  boost::system::error_code ec;
  BufferType buf;
  boost::asio::async_read(socket, buf, this_fiber[ec]);
  // ...
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>with_intr()</code> will set <code>this_fiber.interrupter</code> and return a new token for the
<code>async_*</code> operation. The interrupter is selected based on a trait mechanism —
<code>interrupter_for</code>. This is the specialization for <code>boost::asio::steady_timer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class Clock, class WaitTraits, class Executor&gt;
struct interrupter_for&lt;
  boost::asio::basic_waitable_timer&lt;Clock, WaitTraits, Executor&gt;&gt;
{
  // Called within `with_intr()` before operation begins
  template&lt;class T&gt;
  static void assign(
    T this_fiber,
    boost::asio::basic_waitable_timer&lt;Clock, WaitTraits, Executor&gt;&amp; timer)
  {
    this_fiber.interrupter = [&amp;timer]() { timer.cancel(); };
  }

  // Called after result is ready (just before control goes back to the user)
  template&lt;class T, class... Args&gt;
  static void on_result(T this_fiber, boost::system::error_code&amp; ec,
                        Args&amp;...)
  {
    if (ec == boost::asio::error::operation_aborted)
      throw trial::iofiber::fiber_interrupted();
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>on_result()</code> will be called on the fiber stack just before the result is
converted back to user-consumption (e.g. error codes will be converted to
exceptions if user has not used the <code>this_fiber[ec]</code> syntax).  Arguments are
passed to the trait by <em>non-const ref</em> and you can mutate them before delivery
to the user (e.g. if you clear the error code object, no exception will be
thrown).</p>
</div>
<div class="paragraph">
<p>You may specialize this trait for any object (or sequence of objects). They will
be forwarded from the call to <code>with_intr()</code> to <code>assign()</code>. It is expected that
library providers specialize it for their IO objects so you don&#8217;t have to worry.
Separate headers in this library will specialize this trait for Boost/ASIO IO
objects.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you want to force the use of this safer <code>with_intr()</code> syntax and
forbid plain <code>this_fiber</code> to work as a completion token, just define
<code>TRIAL_IOFIBER_DISABLE_DEFAULT_INTERRUPTER</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This token works only with asynchronous operations that make use of the
<code>async_initiate()</code> helper function. <code>async_completion</code> is not supported.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_suspension_points">Suspension points</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fibers are scheduled cooperatively which means that CPU time is only transferred
from one fiber to the next at defined suspension points. The suspension points
for fibers are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Boost.Asio&#8217;s <code>async_*</code> functions.</p>
</li>
<li>
<p><code>this_fiber.yield()</code>.</p>
</li>
<li>
<p><code>fiber::join(this_fiber)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any functions that are compositions of these functions will also be functions
that serve as suspension points and might throw <code>fiber_interrupted</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>mutex::lock()</code> is a suspension point, but it is not an interruption point. This
is by-design. The primary problem solved by interruption requests is freeing
fibers stalled in operations that might never finish, not “recovering” fibers on
a deadlock. Code your programs correctly.</p>
</div>
<div class="paragraph">
<p>On the other hand, <code>condition_variable::wait()</code> might be associated with
external events so it <strong>is</strong> an interruption point. Refer to its documentation for
more details.</p>
</div>
<div class="paragraph">
<p>It follows POSIX design.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Use <code>this_fiber.yield()</code> if you want to create a suspension point so that a
fiber that is otherwise executing code that contains no suspension points will
respond to an interruption request.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Although <code>this_fiber.yield()</code> is semantically closer to POSIX&#8217;s <code>sched_yield()</code>,
you can use it to achieve the effects of POSIX&#8217;s <code>pthread_testcancel()</code>.</p>
</div>
<div class="paragraph">
<p>It diverges from POSIX because the C&#43;&#43; programmer already has to deal with
RAII and “unexpected” exceptions won&#8217;t fail to clean resources as it&#8217;d happen to
the C user who “forgot” to manage resources using <code>pthread_cleanup_push()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>fiber::interrupt()</code> is guaranteed to <strong>NOT</strong> be an interruption point.
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Check <a href="../background/"><em>background(7)</em></a> for a more comprehensive list.
</div>
</div>


        

        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://vinipsmaker.github.io/iofiber/tutorial/iofiber/" data-toggle="tooltip" data-placement="top" title="IOFiber">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://vinipsmaker.github.io/iofiber/tutorial/background/" data-toggle="tooltip" data-placement="top" title="Background">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
        </ul>
        <p class="credits copyright text-muted">
          

          &nbsp;&bull;&nbsp;&copy;
          
            0001
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://vinipsmaker.github.io/iofiber/">IOFiber</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.73.0</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://vinipsmaker.github.io/iofiber/js/main.js"></script>
<script src="https://vinipsmaker.github.io/iofiber/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://vinipsmaker.github.io/iofiber/js/load-photoswipe.js"></script>








  </body>
</html>

