+++
title = "mutex"
+++

[source,cpp]
----
template<class Strand>
class basic_mutex;

using mutex = basic_mutex<boost::asio::io_context::strand>;
----

As in Boost.Fiber:

[quote, '<https://www.boost.org/doc/libs/1_71_0/libs/fiber/doc/html/fiber/synchronization.html>']
____
[...] synchronization objects can neither be moved nor copied. A synchronization
object acts as a mutually-agreed rendezvous point between different fibers. If
such an object were copied somewhere else, the new copy would have no
consumers. If such an object were _moved_ somewhere else, leaving the original
instance in an unspecified state, existing consumers would behave strangely.
____

WARNING: https://github.com/blinktrade/iofiber/issues/4[Right now the
implementation only works to synchronize among fibers running in the same
strand].

== Member-functions

=== _Constructor_

[source,cpp]
----
basic_mutex(executor_type executor);
----

Constructs a new mutex.

=== `get_executor()`

[source,cpp]
----
executor_type get_executor() const;
----

Returns the strand associated with this mutex.

=== `lock()`

[source,cpp]
----
void lock(fiber::this_fiber this_fiber)
----

Locks the mutex. If another fiber has already locked the mutex, a call to
`lock()` will suspend the current fiber until the lock is acquired.

NOTE: `lock()` is a suspension point, but it never throws `fiber_interrupted`.

=== `unlock()`

[source,cpp]
----
void unlock()
----

Unlocks the mutex.

The mutex must be locked by the current fiber. Otherwise, the behavior is
undefined.

== Nested types

=== `executor_type`

[source,cpp]
----
using executor_type = Strand;
----

=== `guard`

[source,cpp]
----
class guard
{
public:
    guard(basic_mutex<Strand> &mutex, fiber::this_fiber this_fiber)
        : mutex(&mutex)
    {
        mutex.lock(this_fiber);
    }

    guard(guard &&o)
        : mutex(o.mutex)
    {
        o.mutex = nullptr;
    }

    guard(const guard &) = delete;

    ~guard()
    {
        if (!mutex) // moved
            return;

        mutex->unlock();
    }

private:
    basic_mutex<Strand> *mutex;
};
----
